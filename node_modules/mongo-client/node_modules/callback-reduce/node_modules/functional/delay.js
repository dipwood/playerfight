"use strict";

if (typeof(setTimeout) === "undefined")
  var setTimeout = require("timers").setTimeout

function Scheduler(require, exports) {
  // In IE 8 (at least) `postMessage` is synchronous so we
  // assume that `postMessage` is async only if `addEventListener` is defined.
  var isPostMessageAsync = "addEventListener" in window
  // Array of pending tasks
  var queued = []
  var pending = true
  // Special data we post using `postMessage` to identify our calls.
  var KEY = Math.random().toString(32).substr(2)

  function run(event) {
    if (!event || (window === event.source && KEY === event.data)) {
      var tasks = queued.splice(0)
      var count = tasks.length
      var index = 0
      while (index < count) {
        // Report `exceptions` if scheduled tasks throw them.
        try { tasks[index]() }
        catch (error) { console.error(error) }
      }
      if (event) event.stopPropagation()
      pending = true
    }
  }

  // If asynchronous `postMessage` is supported we use that for enqueuing
  // messages instead of `setTimeout(f, 0)`, since it will be called in the
  // next turn of event loop without extra delay.
  if (isPostMessageAsync) window.addEventListener("message", run, true)

  // Runs task in the next turn of event-loop. This
  // On the next loop around the event loop call this task. This is not a simple
  // alias to `setTimeout(task, 0)`, it's much more efficient, but should not be
  // over used (for animations for example).
  return function schedule(task) {
    // Adding a task to process in next turn of event loop.
    queued.push(task)
    if (pending) {
      pending = false
      // Using `postMessage` to run enqueued tasks in next turn of event-loop.
      if (isPostMessageAsync) window.postMessage(KEY, "*")
      // If async `postMessage` is not available falling back to
      // `setTimeout(f, 0)`
      else setTimeout(run, 0)
    }
  }
}

var nextTick = typeof(process) !== "undefined" &&
               typeof(process.nextTick) === "function" &&
               process.nextTick

var schedule = nextTick || Scheduler()

/**
 * Much like setTimeout, invokes function after wait milliseconds. If you pass
 * the optional arguments, they will be forwarded on to the function when it is
 * invoked.
 */
function delay(f, ms) {
  var params = Array.slice(arguments, 2)
  setTimeout(function(context) { return f.apply(context, args); }, ms, this);
}
