{
  "name": "callback-reduce",
  "id": "callback-reduce",
  "version": "1.1.0",
  "description": "Callbacks made reducible",
  "keywords": [
    "callback",
    "reduce",
    "reducible",
    "stream",
    "promise",
    "eventual"
  ],
  "author": {
    "name": "Irakli Gozalishvili",
    "email": "rfobic@gmail.com",
    "url": "http://jeditoolkit.com"
  },
  "homepage": "https://github.com/Gozala/callback-reduce",
  "repository": {
    "type": "git",
    "url": "https://github.com/Gozala/callback-reduce.git",
    "web": "https://github.com/Gozala/callback-reduce"
  },
  "bugs": {
    "url": "http://github.com/Gozala/callback-reduce/issues/"
  },
  "devDependencies": {
    "test": "~0.6.0",
    "repl-utils": "~2.0.1",
    "reducers": "~2.0.0"
  },
  "main": "./callback.js",
  "scripts": {
    "test": "node test/index.js",
    "repl": "node node_modules/repl-utils"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/Gozala/callback-reduce/License.md"
    }
  ],
  "dependencies": {
    "functional": "~1.0.0",
    "reducible": "Raynos/reducible#v1.0.6"
  },
  "readme": "# callback-reduce\n\n[![Build Status](https://secure.travis-ci.org/Gozala/callback-reduce.png)](http://travis-ci.org/Gozala/callback-reduce)\n\nReducers is a great abstraction for working with collections of values\neventual or not. In fact it's great because API for working with data is\nsame map/reduce regardless of weather it's sync or async.\n\n\n```js\nvar fold = require(\"reducers/fold\")\nvar filter = require(\"reducers/filter\")\nvar map = require(\"reducers/map\")\n\n// Sync\nfold(filter(map(array, JSON.parse), isCached), accumulate)\n\n// Async\nfold(filter(map(stream, JSON.parse), isCached), accumulate)\n```\n\nAnother cool concept about reducers is that allows you to work with non sequnce\nvalues with the same API. It just treats atomic vaules as sequences of themself.\n\n```js\nvar fold = require(\"reducers/fold\")\nfunction sum(sequence) {\n  return fold(sequence, function(item, result) {\n    return result + item\n  }, 0)\n}\n\nfold(sum(15), console.log.bind(0, \"=>\"))            // => 15 undefined\nfold(sum([ 15, 3, 7 ]), console.log.bind(0, \"=>\"))  // => 25 undefined\n```\n\nBut there are bunch of async APIs around that are designed in terms of:\ndo action provide a callback, where you'll handle either error or value.\n\n```js\nvar fs = require(\"fs\")\n\nfunction getPackageName(path, callback) {\n  fs.readFile(path, function(error, buffer) {\n    if (error) return callback(error)\n    var json = JSON.parse(buffer.toString())\n    callback(error, json.name)\n  })\n}\n\ngetPackageName(\"./package.json\", console.log) // => null \"callback-reduce\"\n```\n\nWhich is ok but not very composable and there is no simple to transform data.\nBut with reducers we like the fact of unified API that works on the data\nstructures regardless of their nature or timing. This libarray lets you get\nreducible callbacks for callback styled functions!\n\n```js\nvar fs = require(\"fs\")\nvar map = require(\"reducers/map\")\nvar callback = require(\"callback-reduce\")\nvar fold = require(\"reducers/fold\")\n\nvar content = callback(fs.readFile, \"./package.json\")\nvar json = map(map(content, String), JSON.parse)\nvar name = map(json, function($) { return $.name })\n\nfold(name, console.log.bind(0, \"=>\"))     // => \"callback-reduce\" undefined\n```\n\nAnd of course it's lazy and compasable with rest of the API that reducers\nprovide. For more complicated example see:\n\n```js\nvar print = require(\"reducers/debug/print\")\n\nvar fs = require(\"fs\")\nvar path = require(\"path\")\n\nvar callback = require(\"callback-reduce\")\nvar expand = require(\"reducers/expand\")\nvar map = require(\"reducers/map\")\nvar filter = require(\"reducers/filter\")\nvar concat = require(\"reducers/concat\")\nvar cache = require(\"cache-reduce/cache\")\n\n\nfunction lstree(root) {\n  // Get sequence of directory entries, also we cache it as we read\n  // from it several times.\n  var entries = cache(callback(fs.readdir, root))\n  // Resolve entries to the current path.\n  var paths = map(entries, path.join.bind(path, root))\n  // Expand sequence of paths, to associated stats. Unfortunately node does not\n  // keeps path info in the stats so we need to hack this up. Otherwise it would\n  // have being just: var stats = expand(paths, callback.bind(fs, fs.stats))\n  var stats = expand(paths, function(path) {\n    return map(callback(fs.stat, path), function(stats) {\n      stats.toString = path.toString.bind(path)\n      return stats\n    })\n  })\n  // Filter & map file paths.\n  var files = map(filter(stats, function($) { return $.isFile() }), String)\n  // Filter & map directory paths.\n  var dirs = map(filter(stats, function($) { return $.isDirectory() }), String)\n\n  // Return concatination given path, file paths, and all the nested paths.\n  return concat(root, files, expand(dirs, lstree))\n}\n\nprint(lstree(\"./\"))\n```\n\n## passback\n\nConverts a reducible into a callback\n\n```js\nvar passback = require(\"callback-reduce/passback\")\nvar fs = require(\"fs\")\nvar callback = require(\"callback-reduce\")\n\nvar reducible = callback(fs.stat, \".\")\n\npassback(reducible, function (err, stat) {\n  /* do stuff */\n})\n```\n\nAlso takes an optional packing function, to pack the arguments.\n\nIf you were to pass `Array` it would pack the entire content\n  of the reducible into an array.\n\n```js\nvar passback = require(\"callback-reduce/passback\")\nvar fs = require(\"fs\")\nvar callback = require(\"callback-reduce\")\n\nvar reducible = callback(fs.readdir, \"./\")\n\npassback(reducible, Array, function (err, files) {\n  /* do stuff */\n})\n```\n\n## Install\n\n    npm install callback-reduce\n\n\n[reducers]:https://github.com/Gozala/reducers\n",
  "readmeFilename": "Readme.md",
  "_id": "callback-reduce@1.1.0",
  "dist": {
    "shasum": "edd7bcb4430cec896226888496e328b5f364ad90"
  },
  "_resolved": "git://github.com/Raynos/callback-reduce#5a50a8551ac0d78d998dbb48828c09eb0f7cd067",
  "_from": "git://github.com/Raynos/callback-reduce#dedup",
  "_fromGithub": true
}
